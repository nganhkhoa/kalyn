(import "../Stdlib.kalyn")

(public defn foldr (Func (Func a b b) b (List a) b)
  (func init elts)
  (case elts
    (Null init)
    ((Cons fst rst)
     (func fst (foldr func init rst)))))

(public defn foldl (Func (Func b a b) b (List a) b)
  (func init elts)
  (case elts
    (Null init)
    ((Cons fst rst)
     (foldl func (func init fst) rst))))

(public defn map (Func (Func a b) (List a) (List b))
  (func)
  (foldr (lambda (elt rst)
           (Cons (func elt) rst))
         Null))

(public defn filter (Func (Func a Bool) (List a) (List a))
  (pred)
  (foldr (lambda (elt rst)
           (case (pred elt)
             (False rst)
             (True (Cons elt rst))))
         Null))

(public def length (Func (List a) Int)
  (foldr (const (+ 1)) 0))

(public defn join (Func (List a) (List a) (List a))
  (left right)
  (foldr Cons right left))

(public defn replicate (Func Int a (List a))
  (n elt)
  (case (<=Int n 0)
    (False (Cons elt (replicate (- n 1) elt)))
    (True Null)))

(public def reverse (Func (List a) (List a))
  (foldl (flip Cons) []))

(public defn append (Func (List a) (List a) (List a))
  (left right)
  (foldr Cons right left))

(public def concat (Func (List (List a)) (List a))
  (foldr append []))

(public defn concatMap (Func (Func a (List b)) (List a) (List b))
  (func)
  (comp concat (map func)))

(public defn intersperse (Func a (List a) (List a))
  (elt list)
  (case list
    ([] [])
    ([x] [x])
    ((Cons x xs)
     (Cons x (Cons elt (intersperse elt xs))))))

(public defn intercalate (Func (List a) (List (List a)) (List a))
  (xs xss)
  (concat (intersperse xs xss)))

(public defn head (Func (List a) a)
  ((Cons fst _))
  fst)

(public defn tail (Func (List a) (List a))
  ((Cons _ rst))
  rst)

(public defn iterate (Func (Func a a) a Int (List a))
  (func start num)
  (if (<=Int num 0)
    []
    (Cons start (iterate func (func start) (- num 1)))))

(public defn findIndices (Func (Func a Bool) (List a) (List Int))
  (pred)
  (let ((findIndices (lambda (idx elts)
                       (case elts
                         (Null Null)
                         ((Cons elt elts)
                          (if (pred elt)
                            (Cons idx (findIndices (+ idx 1) elts))
                            (findIndices (+ idx 1) elts)))))))
    (findIndices 0)))

(public defn findIndex (Func (Func a Bool) (List a) Int)
  (pred)
  (comp head (findIndices pred)))

(public defn take (Func Int (List a) (List a))
  (n elts)
  (if (<=Int n 0)
    Null
    (case elts
      (Null Null)
      ((Cons fst rst)
       (Cons fst (take (- n 1) rst))))))

(public defn drop (Func Int (List a) (List a))
  (n elts)
  (if (<=Int n 0)
    elts
    (case elts
      (Null Null)
      ((Cons fst rst)
       (drop (- n 1) rst)))))

(public defn scanl (Func (Func b a b) b (List a) (List b))
  (f q ls)
  (Cons q (case ls
            (Null Null)
            ((Cons x xs)
             (scanl f (f q x) xs)))))

(public defn zipWith (Func (Func a b c) (List a) (List b) (List c))
  (func as bs)
  (case (Pair as bs)
    ((Pair (Cons a as) (Cons b bs))
     (Cons (func a b) (zipWith func as bs)))
    (_ Null)))

(public def zip (Func (List a) (List b) (List (Pair a b)))
  (zipWith Pair))

(public defn last (Func (List a) a)
  (elts)
  (case elts
    ((Cons elt Null) elt)
    ((Cons _ rst) (last rst))))
